c Dualiza #SAT Solver
c Copyright (C) 2017-2018 Armin Biere Johannes Kepler University Linz
c Version 008 fd2491936815cc861c7a131dcd7ee002220f630d
c Released Fri Jun 15 08:10:33 2018 +0200
c Compiled Fri Jun 15 09:56:52 CEST 2018
c System Linux fmvi7ab 4.4.0-127-generic x86_64
c Compiler gcc -Wall -g3
c default counting mode
c --verbosity=2147483647
c --logging=1
c reading from 'cnfs/1008.cnf'
c trying to determine file info of input file 'cnfs/1008.cnf'
c assuming DIMACS file info after peeking at 3 characters
c parsing input as DIMACS file
c LOG parsed number of variables 5 in DIMACS header
c LOG parsed number of clauses 3 in DIMACS header
c parsed 'p cnf 5 3' header
c LOG connecting 5 input gates to DIMACS variables
c LOG new INPUT gate 0
c enlarged symbol table from 0 to 1
c LOG new symbol 'x1'
c LOG DIMACS variable 1 connected to input gate 0 with symbol 'x1'
c LOG new INPUT gate 1
c enlarged symbol table from 1 to 2
c LOG new symbol 'x2'
c LOG DIMACS variable 2 connected to input gate 1 with symbol 'x2'
c LOG new INPUT gate 2
c enlarged symbol table from 2 to 4
c LOG new symbol 'x3'
c LOG DIMACS variable 3 connected to input gate 2 with symbol 'x3'
c LOG new INPUT gate 3
c LOG new symbol 'x4'
c LOG DIMACS variable 4 connected to input gate 3 with symbol 'x4'
c LOG new INPUT gate 4
c enlarged symbol table from 4 to 8
c LOG new symbol 'x5'
c LOG DIMACS variable 5 connected to input gate 4 with symbol 'x5'
c LOG start clause 1
c LOG new OR gate 5
c LOG INPUT gate 0 connected as 1st input to OR gate 5
c LOG INPUT gate 1 connected negated as 2nd input to OR gate 5
c LOG end clause 1
c LOG start clause 2
c LOG new OR gate 6
c LOG INPUT gate 0 connected as 1st input to OR gate 6
c LOG INPUT gate 2 connected negated as 2nd input to OR gate 6
c LOG end clause 2
c LOG start clause 3
c LOG new OR gate 7
c LOG INPUT gate 0 connected negated as 1st input to OR gate 7
c LOG INPUT gate 1 connected negated as 2nd input to OR gate 7
c LOG end clause 3
c LOG new AND gate 8
c LOG OR gate 5 connected as 1st input to AND gate 8
c LOG OR gate 6 connected as 2nd input to AND gate 8
c LOG OR gate 7 connected as 3rd input to AND gate 8
c deleting input reader of 'cnfs/1008.cnf' after reading 32 bytes
c generating dual circuit for counting with SAT engine
c LOG new INPUT gate 0
c LOG copying input 0 gate 0 symbol 'x1'
c LOG new INPUT gate 1
c LOG copying input 1 gate 1 symbol 'x2'
c LOG new INPUT gate 2
c LOG copying input 2 gate 2 symbol 'x3'
c LOG new INPUT gate 3
c LOG copying input 3 gate 3 symbol 'x4'
c LOG new INPUT gate 4
c LOG copying input 4 gate 4 symbol 'x5'
c LOG new AND gate 5
c LOG INPUT gate 0 connected negated as 1st input to AND gate 5
c LOG INPUT gate 1 connected as 2nd input to AND gate 5
c LOG new AND gate 6
c LOG INPUT gate 0 connected negated as 1st input to AND gate 6
c LOG INPUT gate 2 connected as 2nd input to AND gate 6
c LOG new AND gate 7
c LOG INPUT gate 0 connected as 1st input to AND gate 7
c LOG INPUT gate 1 connected as 2nd input to AND gate 7
c LOG new OR gate 8
c LOG AND gate 5 connected as 1st input to OR gate 8
c LOG AND gate 6 connected as 2nd input to OR gate 8
c LOG AND gate 7 connected as 3rd input to OR gate 8
c counting with dual SAT engine
c LOG new primal CNF
c LOG new dual CNF
c LOG starting to encode first circuit
c LOG resetting pos, neg, and mark fields of circuit
c cone of influence: 4 pos, 2 neg, 1 both, 2 disconnected
c LOG resetting code and root fields of circuit
c LOG encoding input 0 symbol x1 as 1
c LOG encoding input 1 symbol x2 as 2
c LOG encoding input 2 symbol x3 as 3
c LOG encoding input 3 symbol x4 as 4
c LOG encoding input 4 symbol x5 as 5
c encoded 5 inputs
c LOG starting to encode roots of first circuit
c LOG encoded new primal size 2 clause[0] 1 -2
c LOG added clause 0 to primal CNF
c LOG encoded new primal size 2 clause[0] 1 -3
c LOG added clause 1 to primal CNF
c LOG encoded new primal size 2 clause[0] -1 -2
c LOG added clause 2 to primal CNF
c encoded 0 gates of first circuit
c LOG starting to encode second circuit
c LOG resetting code and root fields of circuit
c LOG encoding input 0 symbol x1 as 1
c LOG encoding input 1 symbol x2 as 2
c LOG encoding input 2 symbol x3 as 3
c LOG encoding input 3 symbol x4 as 4
c LOG encoding input 4 symbol x5 as 5
c encoded 5 inputs
c LOG starting to encode roots of second circuit
c LOG encoding 2-ary AND gate 5 with literal 6
c LOG encoded new dual size 2 clause[0] -6 -1
c LOG added clause 0 to dual CNF
c LOG encoded new dual size 2 clause[0] -6 2
c LOG added clause 1 to dual CNF
c LOG encoded new dual size 3 clause[0] 6 1 -2
c LOG added clause 2 to dual CNF
c LOG encoding 2-ary AND gate 6 with literal 7
c LOG encoded new dual size 2 clause[0] -7 -1
c LOG added clause 3 to dual CNF
c LOG encoded new dual size 2 clause[0] -7 3
c LOG added clause 4 to dual CNF
c LOG encoded new dual size 3 clause[0] 7 1 -3
c LOG added clause 5 to dual CNF
c LOG encoding 2-ary AND gate 7 with literal 8
c LOG encoded new dual size 2 clause[0] -8 1
c LOG added clause 6 to dual CNF
c LOG encoded new dual size 2 clause[0] -8 2
c LOG added clause 7 to dual CNF
c LOG encoded new dual size 3 clause[0] 8 -1 -2
c LOG added clause 8 to dual CNF
c LOG encoded new dual size 3 clause[0] 6 7 8
c LOG added clause 9 to dual CNF
c encoded 3 gates of second circuit
c encoded 8 inputs and gates in total
c primal CNF with 3 clauses
c dual CNF with 10 clauses
c LOG encoding input 0 symbol x1 as 1
c LOG encoding input 1 symbol x2 as 2
c LOG encoding input 2 symbol x3 as 3
c LOG encoding input 3 symbol x4 as 4
c LOG encoding input 4 symbol x5 as 5
c LOG found 5 encoded inputs
c LOG 0 new solver over 3 primal and 10 dual clauses 5 shared variables
c LOG 0 maximum shared variable index 5
c LOG 0 maximum variable index 3 in primal CNF
c LOG 0 no primal gate variables
c LOG 0 maximum variable index 8 in dual CNF
c LOG 0 3 dual gate variables 6 ... 8
c LOG 0 minimum variable index 6 above 5 in dual CNF
c LOG 0 maximum variable index 8
c LOG 0 5 primal or shared variables
c LOG 0 relevant shared variable 1
c LOG 0 relevant shared variable 2
c LOG 0 relevant shared variable 3
c LOG 0 relevant shared variable 4
c LOG 0 relevant shared variable 5
c LOG 0 found 5 relevant shared variables
c LOG 0 found 0 irrelevant shared variables
c LOG 0 found 0 private primal variables
c LOG 0 dual variable 6
c LOG 0 dual variable 7
c LOG 0 dual variable 8
c LOG 0 found 3 private dual variables
c LOG 0 connecting variables
c LOG 0 relevant enqueue variable 1 stamp 1
c LOG 0 updating to search relevant variable 1 next in relevant queue
c LOG 0 relevant enqueue variable 2 stamp 2
c LOG 0 updating to search relevant variable 2 next in relevant queue
c LOG 0 relevant enqueue variable 3 stamp 3
c LOG 0 updating to search relevant variable 3 next in relevant queue
c LOG 0 relevant enqueue variable 4 stamp 4
c LOG 0 updating to search relevant variable 4 next in relevant queue
c LOG 0 relevant enqueue variable 5 stamp 5
c LOG 0 updating to search relevant variable 5 next in relevant queue
c LOG 0 default initial phase 1
c LOG 0 initial reduce interval 2000
c LOG 0 initial reduce increment 300
c LOG 0 initial reduce learned limit 2000
c LOG 0 initial restart conflict limit 2
c LOG 0 new subsume limit 0
c LOG 0 always forcing to split on relevant variables first
c LOG 0 connecting 3 primal clauses to solver
c LOG 0 connecting literal 1 to primal size 2 clause[0] 1 -2
c LOG 0 connecting literal -2 to primal size 2 clause[0] 1 -2
c LOG 0 connecting literal 1 to primal size 2 clause[1] 1 -3
c LOG 0 connecting literal -3 to primal size 2 clause[1] 1 -3
c LOG 0 connecting literal -1 to primal size 2 clause[2] -1 -2
c LOG 0 connecting literal -2 to primal size 2 clause[2] -1 -2
c LOG 0 connecting 10 dual clauses to solver for counting
c LOG 0 connecting literal -6 to dual size 2 clause[0] -6 -1
c LOG 0 connecting literal -1 to dual size 2 clause[0] -6 -1
c LOG 0 connecting literal -6 to dual size 2 clause[1] -6 2
c LOG 0 connecting literal 2 to dual size 2 clause[1] -6 2
c LOG 0 connecting literal 6 to dual size 3 clause[2] 6 1 -2
c LOG 0 connecting literal 1 to dual size 3 clause[2] 6 1 -2
c LOG 0 connecting literal -7 to dual size 2 clause[3] -7 -1
c LOG 0 connecting literal -1 to dual size 2 clause[3] -7 -1
c LOG 0 connecting literal -7 to dual size 2 clause[4] -7 3
c LOG 0 connecting literal 3 to dual size 2 clause[4] -7 3
c LOG 0 connecting literal 7 to dual size 3 clause[5] 7 1 -3
c LOG 0 connecting literal 1 to dual size 3 clause[5] 7 1 -3
c LOG 0 connecting literal -8 to dual size 2 clause[6] -8 1
c LOG 0 connecting literal 1 to dual size 2 clause[6] -8 1
c LOG 0 connecting literal -8 to dual size 2 clause[7] -8 2
c LOG 0 connecting literal 2 to dual size 2 clause[7] -8 2
c LOG 0 connecting literal 8 to dual size 3 clause[8] 8 -1 -2
c LOG 0 connecting literal -1 to dual size 3 clause[8] 8 -1 -2
c LOG 0 connecting literal 6 to dual size 3 clause[9] 6 7 8
c LOG 0 connecting literal 7 to dual size 3 clause[9] 6 7 8
c LOG 0 updating to search relevant variable 5 next in relevant queue
c LOG 0 next relevant decision 5 stamped 5
c LOG 0 relevant decide 5
c LOG 1 incremented solver level
c LOG 1 assume decision 5
c LOG 1 incremented number decision levels to 1
c LOG 1 new last decision level 1
c LOG 1 incremented number relevant levels to 1
c LOG 1 new last relevant level 1
c LOG 1 relevant assign 5 decision
c LOG 1 RULE DX 1	5
c LOG 1 primal propagating 5
c LOG 1 dual propagating 5
c LOG 1 updating to search relevant variable 4 next in relevant queue
c LOG 1 next relevant decision 4 stamped 4
c LOG 1 relevant decide 4
c LOG 2 incremented solver level
c LOG 2 assume decision 4
c LOG 2 incremented number decision levels to 2
c LOG 2 new last decision level 2
c LOG 2 incremented number relevant levels to 2
c LOG 2 new last relevant level 2
c LOG 2 relevant assign 4 decision
c LOG 2 RULE DX 2	4
c LOG 2 primal propagating 4
c LOG 2 dual propagating 4
c LOG 2 updating to search relevant variable 3 next in relevant queue
c LOG 2 next relevant decision 3 stamped 3
c LOG 2 relevant decide 3
c LOG 3 incremented solver level
c LOG 3 assume decision 3
c LOG 3 incremented number decision levels to 3
c LOG 3 new last decision level 3
c LOG 3 incremented number relevant levels to 3
c LOG 3 new last relevant level 3
c LOG 3 relevant assign 3 decision
c LOG 3 RULE DX 3	3
c LOG 3 primal propagating 3
c LOG 3 visiting while propagating 3 primal size 2 clause[1] 1 -3
c LOG 3 forcing 1 primal size 2 clause[1] -3 1
c LOG 3 relevant assign 1 reason primal size 2 clause[1] -3 1
c LOG 3 RULE UP 1	1
c LOG 3 primal propagating 1
c LOG 3 visiting while propagating 1 primal size 2 clause[2] -1 -2
c LOG 3 forcing -2 primal size 2 clause[2] -1 -2
c LOG 3 relevant assign -2 reason primal size 2 clause[2] -1 -2
c LOG 3 RULE UP 2	-2
c LOG 3 primal propagating -2
c LOG 3 all primal and shared variables assigned
c LOG 3 backtrack primal satisfied
c LOG 3 model 1 with 0 unassigned relevant variables
c LOG 3 saving first model
c 
c                   primal    dual  learned primal dual variables log2  log2
c       time  memory   conflicts           clauses              models count
c 
c +    0.00     0.7      0       0      0      3     10       5      0     0
c LOG 3 backtracking to last relevant decision 3 at level 3
c LOG 3 blocking clause size 3 would exceed limit 2
c LOG 3 applying primal satisfied flipping rule
c LOG 3 initialized level 3 flipping count to 2^0 = 1
c LOG 3 relevant unassign -2
c LOG 3 relevant unassign 1
c LOG 3 final level 3 flipping count 1
c LOG 3 decremented number decision levels to 2
c LOG 3 new last decision level 2
c LOG 3 decremented number relevant levels to 2
c LOG 3 new last relevant level 2
c LOG 3 relevant flip 3
c LOG 3 incremented number flipped levels to 1
c LOG 3 new last flipped level 3
c LOG 3 relevant assign -3
c LOG 3 RULE BP1F 1	-3
c LOG 3 primal propagating -3
c LOG 3 dual propagating -3
c LOG 3 visiting while propagating -3 dual size 2 clause[4] -7 3
c LOG 3 dual unit -7 dual size 2 clause[4] 3 -7
c LOG 3 dual assign -7 reason dual size 2 clause[4] 3 -7
c LOG 3 RULE UNT 1	-7
c LOG 3 dual propagating -7
c LOG 3 visiting while propagating -7 dual size 3 clause[5] 7 1 -3
c LOG 3 disconnecting literal 7 from dual size 3 clause[5] 7 1 -3
c LOG 3 connecting literal -3 to dual size 3 clause[5] -3 1 7
c LOG 3 visiting while propagating -7 dual size 3 clause[9] 6 7 8
c LOG 3 disconnecting literal 7 from dual size 3 clause[9] 7 6 8
c LOG 3 connecting literal 8 to dual size 3 clause[9] 8 6 7
c LOG 3 updating to search relevant variable 2 next in relevant queue
c LOG 3 next relevant decision 2 stamped 2
c LOG 3 relevant decide -2
c LOG 4 incremented solver level
c LOG 4 assume decision -2
c LOG 4 incremented number decision levels to 3
c LOG 4 new last decision level 4
c LOG 4 incremented number relevant levels to 3
c LOG 4 new last relevant level 4
c LOG 4 relevant assign -2 decision
c LOG 4 RULE DX 4	-2
c LOG 4 primal propagating -2
c LOG 4 dual propagating -2
c LOG 4 visiting while propagating -2 dual size 2 clause[1] -6 2
c LOG 4 dual unit -6 dual size 2 clause[1] 2 -6
c LOG 4 dual assign -6 reason dual size 2 clause[1] 2 -6
c LOG 4 RULE UNT 2	-6
c LOG 4 visiting while propagating -2 dual size 2 clause[7] -8 2
c LOG 4 dual unit -8 dual size 2 clause[7] 2 -8
c LOG 4 dual assign -8 reason dual size 2 clause[7] 2 -8
c LOG 4 RULE UNT 3	-8
c LOG 4 dual propagating -6
c LOG 4 visiting while propagating -6 dual size 3 clause[2] 6 1 -2
c LOG 4 disconnecting literal 6 from dual size 3 clause[2] 6 1 -2
c LOG 4 connecting literal -2 to dual size 3 clause[2] -2 1 6
c LOG 4 visiting while propagating -6 dual size 3 clause[9] 8 6 7
c LOG 4 conflict dual size 3 clause[9] 6 8 7
c LOG 4 analyze dual
c LOG 4 model 2 with 0 unassigned relevant variables
c +    0.00     0.7      0       1      0      3     10       5      1     1
c LOG 4 backtracking to last relevant decision -2 at level 4
c LOG 4 blocking clause size 3 would exceed limit 2
c LOG 4 applying dual conflict flipping rule
c LOG 4 initialized level 4 flipping count to 2^1 = 2
c LOG 4 dual unassign -8
c LOG 4 dual unassign -6
c LOG 4 final level 4 flipping count 2
c LOG 4 decremented number decision levels to 2
c LOG 4 new last decision level 2
c LOG 4 decremented number relevant levels to 2
c LOG 4 new last relevant level 2
c LOG 4 relevant flip -2
c LOG 4 incremented number flipped levels to 2
c LOG 4 new last flipped level 4
c LOG 4 relevant assign 2
c LOG 4 RULE BN0F 1	2
c LOG 4 primal propagating 2
c LOG 4 visiting while propagating 2 primal size 2 clause[0] 1 -2
c LOG 4 forcing 1 primal size 2 clause[0] -2 1
c LOG 4 relevant assign 1 reason primal size 2 clause[0] -2 1
c LOG 4 RULE UP 3	1
c LOG 4 visiting while propagating 2 primal size 2 clause[2] -1 -2
c LOG 4 conflict 1 primal size 2 clause[2] -2 -1
c LOG 4 analyze primal
c LOG 4 resolving primal size 2 clause[2] -2 -1
c LOG 4 relevant seen literal -2
c LOG 4 seen level 4
c LOG 4 relevant seen literal -1
c LOG 4 unresolved literals 2
c LOG 4 relevant resolving literal 1
c LOG 4 resolving primal size 2 clause[0] -2 1
c LOG 4 unresolved literals 1
c LOG 4 relevant first UIP literal 2
c LOG 4 relevant bump variable 1
c LOG 4 relevant dequeue variable 1 stamp 1
c LOG 4 relevant enqueue variable 1 stamp 6
c LOG 4 relevant bump variable 2
c LOG 4 relevant dequeue variable 2 stamp 2
c LOG 4 updating to search relevant variable 3 next in relevant queue
c LOG 4 relevant enqueue variable 2 stamp 7
c LOG 4 seen 1 levels
c LOG 4 new fast moving glue average 1.00
c LOG 4 new slow moving glue average 1.00
c LOG 4 first sorted literal -2
c LOG 4 jump level 0 of learned clause of size 1
c LOG 4 found 2 flipped levels above 0
c LOG 4 applying primal conflict flipping rule at level 2
c LOG 4 relevant unassign 1
c LOG 4 updating to search relevant variable 1 next in relevant queue
c LOG 4 relevant unassign 2
c LOG 4 updating to search relevant variable 2 next in relevant queue
c LOG 4 accumulating level 2 flipping count 2
c LOG 4 decremented number flipped levels to 1
c LOG 4 new last flipped level 3
c LOG 3 decremented solver level
c LOG 3 dual unassign -7
c LOG 3 relevant unassign -3
c LOG 3 accumulating level 2 flipping count 1
c LOG 3 decremented number flipped levels to 0
c LOG 3 new last flipped level 0
c LOG 2 decremented solver level
c LOG 2 final level 2 flipping count 3
c LOG 2 decremented number decision levels to 1
c LOG 2 new last decision level 1
c LOG 2 decremented number relevant levels to 1
c LOG 2 new last relevant level 1
c LOG 2 relevant flip 4
c LOG 2 incremented number flipped levels to 1
c LOG 2 new last flipped level 2
c LOG 2 relevant assign -4
c LOG 2 RULE BP0F 1	-4
c LOG 2 primal propagating -4
c LOG 2 dual propagating -4
c LOG 2 updating to search relevant variable 2 next in relevant queue
c LOG 2 next relevant decision 2 stamped 7
c LOG 2 relevant decide -2
c LOG 3 incremented solver level
c LOG 3 assume decision -2
c LOG 3 incremented number decision levels to 2
c LOG 3 new last decision level 3
c LOG 3 incremented number relevant levels to 2
c LOG 3 new last relevant level 3
c LOG 3 relevant assign -2 decision
c LOG 3 RULE DX 5	-2
c LOG 3 primal propagating -2
c LOG 3 dual propagating -2
c LOG 3 visiting while propagating -2 dual size 2 clause[1] 2 -6
c LOG 3 dual unit -6 dual size 2 clause[1] 2 -6
c LOG 3 dual assign -6 reason dual size 2 clause[1] 2 -6
c LOG 3 RULE UNT 4	-6
c LOG 3 visiting while propagating -2 dual size 2 clause[7] 2 -8
c LOG 3 dual unit -8 dual size 2 clause[7] 2 -8
c LOG 3 dual assign -8 reason dual size 2 clause[7] 2 -8
c LOG 3 RULE UNT 5	-8
c LOG 3 dual propagating -6
c LOG 3 visiting while propagating -6 dual size 3 clause[9] 6 8 7
c LOG 3 disconnecting literal 6 from dual size 3 clause[9] 6 8 7
c LOG 3 connecting literal 7 to dual size 3 clause[9] 7 8 6
c LOG 3 dual propagating -8
c LOG 3 visiting while propagating -8 dual size 3 clause[8] 8 -1 -2
c LOG 3 disconnecting literal 8 from dual size 3 clause[8] 8 -1 -2
c LOG 3 connecting literal -2 to dual size 3 clause[8] -2 -1 8
c LOG 3 visiting while propagating -8 dual size 3 clause[9] 7 8 6
c LOG 3 dual unit 7 dual size 3 clause[9] 8 7 6
c LOG 3 dual assign 7 reason dual size 3 clause[9] 8 7 6
c LOG 3 RULE UNT 6	7
c LOG 3 dual propagating 7
c LOG 3 visiting while propagating 7 dual size 2 clause[3] -7 -1
c LOG 3 shared unit -1 dual size 2 clause[3] -7 -1
c LOG 4 incremented solver level
c LOG 4 assume decision 1
c LOG 4 incremented number decision levels to 3
c LOG 4 new last decision level 4
c LOG 4 incremented number relevant levels to 3
c LOG 4 new last relevant level 4
c LOG 4 relevant assign 1 decision
c LOG 4 conflict dual size 2 clause[3] -7 -1
c LOG 4 RULE UNX 1	-1
c LOG 4 analyze dual
c LOG 4 model 3 with 0 unassigned relevant variables
c m    0.00     0.7      1       2      0      3     10       5      1     2
c LOG 4 backtracking to last relevant decision 1 at level 4
c LOG 4 blocking clause size 3 would exceed limit 2
c LOG 4 applying dual conflict flipping rule
c LOG 4 initialized level 4 flipping count to 2^1 = 2
c LOG 4 final level 4 flipping count 2
c LOG 4 decremented number decision levels to 2
c LOG 4 new last decision level 3
c LOG 4 decremented number relevant levels to 2
c LOG 4 new last relevant level 3
c LOG 4 relevant flip 1
c LOG 4 incremented number flipped levels to 2
c LOG 4 new last flipped level 4
c LOG 4 relevant assign -1
c LOG 4 RULE BN0F 2	-1
c LOG 4 primal propagating -1
c LOG 4 visiting while propagating -1 primal size 2 clause[0] -2 1
c LOG 4 visiting while propagating -1 primal size 2 clause[1] -3 1
c LOG 4 forcing -3 primal size 2 clause[1] 1 -3
c LOG 4 relevant assign -3 reason primal size 2 clause[1] 1 -3
c LOG 4 RULE UP 4	-3
c LOG 4 primal propagating -3
c LOG 4 all primal and shared variables assigned
c LOG 4 backtrack primal satisfied
c LOG 4 model 4 with 0 unassigned relevant variables
c +    0.00     0.7      1       2      0      3     10       5      2     2
c LOG 4 backtracking to last relevant decision -2 at level 3
c LOG 4 blocking clause size 2 below limit 2
c LOG 4 applying primal satisfied learning rule
c LOG 4 backtrack to level 3
c LOG 4 relevant unassign -3
c LOG 4 relevant unassign -1
c LOG 4 decremented number flipped levels to 1
c LOG 4 new last flipped level 2
c LOG 3 decremented solver level
c LOG 3 adding decision blocking clause 1 for decision -2 at level 3
c LOG 3 adding decision relevant literal 2 from decision level 3
c LOG 3 adding decision relevant literal -5 from decision level 1
c LOG 3 found blocking clause of length 2
c LOG 3 dual unassign 7
c LOG 3 dual unassign -8
c LOG 3 dual unassign -6
c LOG 3 relevant unassign -2
c LOG 3 decremented number decision levels to 1
c LOG 3 new last decision level 1
c LOG 3 decremented number relevant levels to 1
c LOG 3 new last relevant level 1
c LOG 2 decremented solver level
c LOG 2 decision blocking primal size 2 clause[0] 2 -5
c LOG added clause 3 to primal CNF
c LOG 2 connecting literal 2 to primal size 2 clause[3] 2 -5
c LOG 2 connecting literal -5 to primal size 2 clause[3] 2 -5
c LOG 2 relevant assign 2 reason primal size 2 clause[3] 2 -5
c LOG 2 RULE BP1L 1	2	2 -5
c LOG 2 trying to subsume at most 4 clauses
c LOG 2 marking literal 2
c LOG 2 marking literal -5
c LOG 2 unmarking literal 2
c LOG 2 unmarking literal -5
c LOG 2 subsumed 0 clauses
c LOG 2 primal propagating 2
c LOG 2 visiting while propagating 2 primal size 2 clause[0] 1 -2
c LOG 2 forcing 1 primal size 2 clause[0] -2 1
c LOG 2 relevant assign 1 reason primal size 2 clause[0] -2 1
c LOG 2 RULE UP 5	1
c LOG 2 visiting while propagating 2 primal size 2 clause[2] -2 -1
c LOG 2 conflict 2 primal size 2 clause[2] -2 -1
c LOG 2 analyze primal
c LOG 2 resolving primal size 2 clause[2] -2 -1
c LOG 2 relevant seen literal -2
c LOG 2 seen level 2
c LOG 2 relevant seen literal -1
c LOG 2 unresolved literals 2
c LOG 2 relevant resolving literal 1
c LOG 2 resolving primal size 2 clause[0] -2 1
c LOG 2 unresolved literals 1
c LOG 2 relevant first UIP literal 2
c LOG 2 relevant bump variable 1
c LOG 2 relevant dequeue variable 1 stamp 6
c LOG 2 relevant enqueue variable 1 stamp 8
c LOG 2 relevant bump variable 2
c LOG 2 relevant dequeue variable 2 stamp 7
c LOG 2 updating to search relevant variable 1 next in relevant queue
c LOG 2 relevant enqueue variable 2 stamp 9
c LOG 2 seen 1 levels
c LOG 2 new fast moving glue average 1.00
c LOG 2 new slow moving glue average 1.00
c LOG 2 first sorted literal -2
c LOG 2 jump level 0 of learned clause of size 1
c LOG 2 found 1 flipped levels above 0
c LOG 2 discounting 1 levels above back-jump level 0
c LOG 2 learning clause number 1 of size 1
c LOG 2 learned new primal redundant glue 1 size 1 clause[0] -2
c LOG added clause 4 to primal CNF
c LOG 2 back-jump 1 to level 0
c LOG 2 relevant unassign 1
c LOG 2 relevant unassign 2
c LOG 2 updating to search relevant variable 2 next in relevant queue
c LOG 2 relevant unassign -4
c LOG 2 discounted actual models 3
c d    0.00     0.7      2       2      1      4     10       5      2     2
c LOG 2 decremented number flipped levels to 0
c LOG 2 new last flipped level 0
c LOG 1 decremented solver level
c LOG 1 relevant unassign 5
c LOG 1 decremented number decision levels to 0
c LOG 1 new last decision level 0
c LOG 1 decremented number relevant levels to 0
c LOG 1 new last relevant level 0
c LOG 0 decremented solver level
c LOG 0 relevant assign -2 reason primal redundant glue 1 size 1 clause[4] -2
c LOG 0 RULE JP0 1	-2	-2
c LOG 0 primal propagating -2
c LOG 0 visiting while propagating -2 primal size 2 clause[3] 2 -5
c LOG 0 forcing -5 primal size 2 clause[3] 2 -5
c LOG 0 relevant assign -5 reason primal size 2 clause[3] 2 -5
c LOG 0 RULE UP 6	-5
c LOG 0 primal propagating -5
c i    0.00     0.7      2       2      1      4     10       3      2     2
c LOG 0 dual propagating -2
c LOG 0 visiting while propagating -2 dual size 2 clause[1] 2 -6
c LOG 0 dual unit -6 dual size 2 clause[1] 2 -6
c LOG 0 dual assign -6 reason dual size 2 clause[1] 2 -6
c LOG 0 RULE UNT 7	-6
c LOG 0 visiting while propagating -2 dual size 2 clause[7] 2 -8
c LOG 0 dual unit -8 dual size 2 clause[7] 2 -8
c LOG 0 dual assign -8 reason dual size 2 clause[7] 2 -8
c LOG 0 RULE UNT 8	-8
c LOG 0 dual propagating -5
c LOG 0 dual propagating -6
c LOG 0 dual propagating -8
c LOG 0 visiting while propagating -8 dual size 3 clause[9] 8 7 6
c LOG 0 dual unit 7 dual size 3 clause[9] 8 7 6
c LOG 0 dual assign 7 reason dual size 3 clause[9] 8 7 6
c LOG 0 RULE UNT 9	7
c LOG 0 dual propagating 7
c LOG 0 visiting while propagating 7 dual size 2 clause[3] -7 -1
c LOG 0 shared unit -1 dual size 2 clause[3] -7 -1
c LOG 1 incremented solver level
c LOG 1 assume decision 1
c LOG 1 incremented number decision levels to 1
c LOG 1 new last decision level 1
c LOG 1 incremented number relevant levels to 1
c LOG 1 new last relevant level 1
c LOG 1 relevant assign 1 decision
c LOG 1 conflict dual size 2 clause[3] -7 -1
c LOG 1 RULE UNX 2	-1
c LOG 1 analyze dual
c LOG 1 model 5 with 1 unassigned relevant variables
c m    0.00     0.7      2       3      1      4     10       3      2     2
c LOG 1 backtracking to last relevant decision 1 at level 1
c LOG 1 blocking clause size 1 below limit 2
c LOG 1 applying dual conflict learning rule
c LOG 1 backtrack to level 1
c LOG 1 adding decision blocking clause 2 for decision 1 at level 1
c LOG 1 adding decision relevant literal -1 from decision level 1
c LOG 1 found blocking clause of length 1
c LOG 1 relevant unassign 1
c LOG 1 decremented number decision levels to 0
c LOG 1 new last decision level 0
c LOG 1 decremented number relevant levels to 0
c LOG 1 new last relevant level 0
c LOG 0 decremented solver level
c LOG 0 decision blocking primal size 1 clause[0] -1
c LOG added clause 5 to primal CNF
c LOG 0 relevant assign -1 reason primal size 1 clause[5] -1
c LOG 0 RULE BN0L 1	-1	-1
c LOG 0 primal propagating -1
c LOG 0 visiting while propagating -1 primal size 2 clause[0] -2 1
c LOG 0 visiting while propagating -1 primal size 2 clause[1] 1 -3
c LOG 0 forcing -3 primal size 2 clause[1] 1 -3
c LOG 0 relevant assign -3 reason primal size 2 clause[1] 1 -3
c LOG 0 RULE UP 7	-3
c LOG 0 primal propagating -3
c i    0.00     0.7      2       3      1      5     10       1      2     2
c LOG 0 dual propagating 7
c LOG 0 visiting while propagating 7 dual size 2 clause[3] -7 -1
c LOG 0 visiting while propagating 7 dual size 2 clause[4] 3 -7
c LOG 0 conflict dual size 2 clause[4] -7 3
c LOG 0 analyze dual
c LOG 0 model 6 with 1 unassigned relevant variables
c m    0.00     0.7      2       4      1      5     10       1      2     3
c LOG 0 dual conflict without any relevant decisions left
c LOG 0 RULE EN0 1
NUMBER SATISFYING ASSIGNMENTS
9
c LOG 0 deleting solver
c LOG delete primal CNF
c LOG delete primal size 2 clause[0] 1 -2
c LOG delete primal size 2 clause[1] 1 -3
c LOG delete primal size 2 clause[2] -2 -1
c LOG delete primal size 2 clause[3] 2 -5
c LOG delete primal redundant glue 1 size 1 clause[4] -2
c LOG delete primal size 1 clause[5] -1
c LOG delete dual CNF
c LOG delete dual size 2 clause[0] -6 -1
c LOG delete dual size 2 clause[1] 2 -6
c LOG delete dual size 3 clause[2] -2 1 6
c LOG delete dual size 2 clause[3] -7 -1
c LOG delete dual size 2 clause[4] -7 3
c LOG delete dual size 3 clause[5] -3 1 7
c LOG delete dual size 2 clause[6] -8 1
c LOG delete dual size 2 clause[7] 2 -8
c LOG delete dual size 3 clause[8] -2 -1 8
c LOG delete dual size 3 clause[9] 8 7 6
c deleting circuit with 9 gates
c deleting circuit with 9 gates
c 
c ---- [rules] ---------------------------------------------
c 
c            0 EP1             0 EP0             1 EN0
c            1 BP0F            1 JP0
c            1 BP1F            1 BP1L
c            2 BN0F            1 BN0F
c            5 DX              0 DY              0 DS
c            7 UP              9 UNT
c            2 UNX             0 UNY
c            0 FP              0 FN
c 
c ---- [statistics] ----------------------------------------
c 
c 6 counted partial models (1.2 decisions per model)
c 1 discounted partial models (16.7% per counted model)
c 1 backjumps with discounting (100% of all backjumps)
c 6 conflicts (1500 per second)
c 2 primal conflicts (500 per second)
c 4 dual conflicts (1000 per second)
c 2 dual shared units (50% dual conflicts)
c 7 decisions (1750 per second)
c 34 propagations (0.0 million per second)
c 17 primal propagations (0.0 million per second)
c 17 dual propagations (0.0 million per second)
c 6 backtracked (86% per decision)
c 1 backjumped (50% per conflict)
c 2 blocking clauses (1.5 average length)
c bumped 4 variables (2.0 per primal conflict)
c searched 3 variables (0.4 per decision)
c looked up 5 symbols, 0 collisions (0.0 per look-up)
c 
c ---- [resources] -----------------------------------------
c 
c maximum allocated 6128 bytes (0.0 MB)
c maximum resident set size 5181440 bytes (4.9 MB)
c process time 0.00 seconds
